[{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/series/container-object-storage-interface/","section":"Series","summary":"","title":"Container Object Storage Interface","type":"series"},{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/tags/container-object-storage-interface/","section":"Tags","summary":"","title":"Container Object Storage Interface","type":"tags"},{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Tags","summary":"","title":"Kubernetes","type":"tags"},{"content":" Cloud-native developer and Kubernetes evangelist driving secure, distributed systems innovations and open-source contributions.\n","date":"13 July 2025","externalUrl":null,"permalink":"/authors/shanduur/","section":"Authors","summary":"","title":"Mateusz Urbanek","type":"authors"},{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/","section":"Stateless by design","summary":"","title":"Stateless by design","type":"page"},{"content":"","date":"13 July 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Technical portion of this article is based on v1alpha1 COSI specification.\nIn today\u0026rsquo;s cloud-native landscape, managing storage efficiently is paramount for scalable and resilient applications. Object storage provides a highly available, durable, and often a cost-effective way to store unstructured data such as media files, backups, and logs. Unlike traditional file or block storage, object storage organizes data as objects within buckets, making it easier to manage at scale while offering inherent benefits like metadata tagging and integration with distributed systems.\nContainer Object Storage Interface (COSI) is an emerging standard that provides a unified abstraction layer that enables developers and operators to interact with various object storage systems using a consistent API. It allows organizations simplify the process of integrating and managing object storage backends across diverse environments, whether on-premises, in the cloud or in hybrid deployments.\nConfiguration Structure # The Config struct is the primary configuration object for the storage package. It encapsulates all necessary settings for interacting with different storage providers. This design ensures that all configuration details are centralized and easily maintainable, allowing your application to switch storage backends with minimal code changes.\nThe nested Spec struct defines both generic and provider-specific parameters:\nBucketName: Specifies the target storage container or bucket. This value directs where the data will be stored or retrieved. AuthenticationType: Indicates the method of authentication (either Key or IAM). This ensures that the correct credentials are used when accessing a storage provider. Protocols: An array of strings that informs the system which storage protocols (e.g. S3 or Azure) are supported. The factory uses this to determine the appropriate client to initialize. SecretS3/SecretAzure: These fields hold pointers to the respective secret structures needed for authenticating with S3 or Azure services. Their presence is conditional on the protocols configured. // import \u0026#34;example.com/pkg/storage\u0026#34; package storage type Config struct { Spec Spec `json:\u0026#34;spec\u0026#34;` } type Spec struct { BucketName string `json:\u0026#34;bucketName\u0026#34;` AuthenticationType string `json:\u0026#34;authenticationType\u0026#34;` Protocols []string `json:\u0026#34;protocols\u0026#34;` SecretS3 *s3.SecretS3 `json:\u0026#34;secretS3,omitempty\u0026#34;` SecretAzure *azure.SecretAzure `json:\u0026#34;secretAzure,omitempty\u0026#34;` } Azure Secret Structure # The SecretAzure struct holds authentication credentials for accessing Azure-based storage services. It is essential when interacting with Azure Blob storage, as it contains a shared access token along with an expiration timestamp. The inclusion of the ExpiryTimestamp allows your application to check token validity.\nWhile current COSI implementation doesn\u0026rsquo;t auto-renew tokens, the ExpiryTimestamp provides hooks for future refresh logic.\n// import \u0026#34;example.com/pkg/storage/azure\u0026#34; package azure type SecretAzure struct { AccessToken string `json:\u0026#34;accessToken\u0026#34;` ExpiryTimestamp time.Time `json:\u0026#34;expiryTimeStamp\u0026#34;` } S3 Secret Structure # The SecretS3 struct holds authentication credentials for accessing S3-compatible storage services. This struct includes the endpoint, region, and access credentials required to securely interact with the S3 service. By isolating these values into a dedicated structure, the design helps maintain clear separation between configuration types, thus enhancing code clarity.\n// import \u0026#34;example.com/pkg/storage/s3\u0026#34; package s3 type SecretS3 struct { Endpoint string `json:\u0026#34;endpoint\u0026#34;` Region string `json:\u0026#34;region\u0026#34;` AccessKeyID string `json:\u0026#34;accessKeyID\u0026#34;` AccessSecretKey string `json:\u0026#34;accessSecretKey\u0026#34;` } Factory # The factory pattern1 is used to instantiate the appropriate storage backend based on the provided configuration. We will hide the implementation behind the interface.\nThe factory function examines the configurationâ€™s Protocols array and validates the AuthenticationType along with the corresponding secret. It then returns a concrete implementation of the Storage interface. This method of instantiation promotes extensibility, making it easier to support additional storage protocols in the future, as the COSI specification evolves.\nHere is a minimal interface that supports only basic Delete/Get/Put operations:\ntype Storage interface { Delete(ctx context.Context, key string) error Get(ctx context.Context, key string, wr io.Writer) error Put(ctx context.Context, key string, data io.Reader, size int64) error } Our implementation of factory method can be defined as following:\n// import \u0026#34;example.com/pkg/storage\u0026#34; package storage import ( \u0026#34;fmt\u0026#34; \u0026#34;slices\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;example.com/pkg/storage/azure\u0026#34; \u0026#34;example.com/pkg/storage/s3\u0026#34; ) func New(config Config, ssl bool) (Storage, error) { if slices.ContainsFunc(config.Spec.Protocols, func(s string) bool { return strings.EqualFold(s, \u0026#34;s3\u0026#34;) }) { if !strings.EqualFold(config.Spec.AuthenticationType, \u0026#34;key\u0026#34;) { return nil, fmt.Errorf(\u0026#34;invalid authentication type for s3\u0026#34;) } s3secret := config.Spec.SecretS3 if s3secret == nil { return nil, fmt.Errorf(\u0026#34;s3 secret missing\u0026#34;) } return s3.New(config.Spec.BucketName, *s3secret, ssl) } if slices.ContainsFunc(config.Spec.Protocols, func(s string) bool { return strings.EqualFold(s, \u0026#34;azure\u0026#34;) }) { if !strings.EqualFold(config.Spec.AuthenticationType, \u0026#34;key\u0026#34;) { return nil, fmt.Errorf(\u0026#34;invalid authentication type for azure\u0026#34;) } azureSecret := config.Spec.SecretAzure if azureSecret == nil { return nil, fmt.Errorf(\u0026#34;azure secret missing\u0026#34;) } return azure.New(config.Spec.BucketName, *azureSecret) } return nil, fmt.Errorf(\u0026#34;invalid protocol (%v)\u0026#34;, config.Spec.Protocols) } Clients # As we alredy defined the factory and uppermost configuration, let\u0026rsquo;s get into the details of the clients, that will implement the Storage interface.\nS3 # In the implementation of S3 client, we will use MinIO client library, as it\u0026rsquo;s more lightweight than AWS SDK.\n// import \u0026#34;example.com/pkg/storage/s3\u0026#34; package s3 import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/minio/minio-go/v7\u0026#34; \u0026#34;github.com/minio/minio-go/v7/pkg/credentials\u0026#34; ) type Client struct { s3cli *minio.Client bucketName string } func New(bucketName string, s3secret SecretS3, ssl bool) (*Client, error) { s3cli, err := minio.New(s3secret.Endpoint, \u0026amp;minio.Options{ Creds: credentials.NewStaticV4(s3secret.AccessKeyID, s3secret.AccessSecretKey, \u0026#34;\u0026#34;), Region: s3secret.Region, Secure: ssl, }) if err != nil { return nil, fmt.Errorf(\u0026#34;unable to create client: %w\u0026#34;, err) } return \u0026amp;Client{ s3cli: s3cli, bucketName: bucketName, }, nil } func (c *Client) Delete(ctx context.Context, key string) error { return c.s3cli.RemoveObject(ctx, c.bucketName, key, minio.RemoveObjectOptions{}) } func (c *Client) Get(ctx context.Context, key string, wr io.Writer) error { obj, err := c.s3cli.GetObject(ctx, c.bucketName, key, minio.GetObjectOptions{}) if err != nil { return err } _, err = io.Copy(wr, obj) return err } func (c *Client) Put(ctx context.Context, key string, data io.Reader, size int64) error { _, err := c.s3cli.PutObject(ctx, c.bucketName, key, data, size, minio.PutObjectOptions{}) return err } Azure Blob # In the implementation of Azure client, we will use Azure SDK client library. Note, that the configuration is done with NoCredentials client, as the Azure secret contains shared access signatures (SAS)2.\n// import \u0026#34;example.com/pkg/storage/azure\u0026#34; package azure import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/Azure/azure-sdk-for-go/sdk/storage/azblob\u0026#34; ) type Client struct { azCli *azblob.Client containerName string } func New(containerName string, azureSecret SecretAzure) (*Client, error) { azCli, err := azblob.NewClientWithNoCredential(azureSecret.AccessToken, nil) if err != nil { return nil, fmt.Errorf(\u0026#34;unable to create client: %w\u0026#34;, err) } return \u0026amp;Client{ azCli: azCli, containerName: containerName, }, nil } func (c *Client) Delete(ctx context.Context, blobName string) error { _, err := c.azCli.DeleteBlob(ctx, c.containerName, blobName, nil) return err } func (c *Client) Get(ctx context.Context, blobName string, wr io.Writer) error { stream, err := c.azCli.DownloadStream(ctx, c.containerName, blobName, nil) if err != nil { return fmt.Errorf(\u0026#34;unable to get download stream: %w\u0026#34;, err) } _, err = io.Copy(wr, stream.Body) return err } func (c *Client) Put(ctx context.Context, blobName string, data io.Reader, size int64) error { _, err := c.azCli.UploadStream(ctx, c.containerName, blobName, data, nil) return err } Summing up # Once all components are in place, using the storage package in your application becomes straightforward. The process starts with reading a JSON configuration file, which is then decoded into the Config struct. The factory method selects and initializes the appropriate storage client based on the configuration, enabling seamless integration with either S3 or Azure storage.\nimport ( \u0026#34;encoding/json\u0026#34; \u0026#34;os\u0026#34; \u0026#34;example.com/pkg/storage\u0026#34; ) func example() { f, err := os.Open(\u0026#34;/opt/cosi/BucketInfo.json\u0026#34;) if err != nil { panic(err) } defer f.Close() var cfg storage.Config if err := json.NewDecoder(f).Decode(\u0026amp;cfg); err != nil { panic(err) } client, err := storage.New(cfg, true) if err != nil { panic(err) } // use client Put/Get/Delete // ... } https://en.wikipedia.org/wiki/Factory_method_pattern\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://learn.microsoft.com/en-us/azure/storage/common/storage-sas-overview\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"13 July 2025","externalUrl":null,"permalink":"/posts/2025/0713-using-cosi-with-go-apps/","section":"Posts","summary":"An approach to creating a wrapper that simplifies the way to store and retrieve information, all while maintaining flexibility of using different storage providers.","title":"Using COSI v1alpha1 with Go apps","type":"posts"},{"content":"The Container Object Storage Interface (COSI) is a Kubernetes-native standard for managing object storage buckets and credentials. By abstracting provider-specific details, COSI enables dynamic provisioning, secure access management, and seamless integration with applications. In this guide, weâ€™ll deploy COSI on a Kubernetes cluster, configure a Linode driver, and deploy a sample app that leverages automated object storage workflows.\nInstallation # COSI requires a controller and Custom Resource Definitions (CRDs) to extend Kubernetes\u0026rsquo; API for object storage operations. Install them using the official Helm chart:\nkubectl apply \\ -k \u0026#39;https://github.com/kubernetes-sigs/container-object-storage-interface//?ref=v0.2.1\u0026#39; This deploys the COSI controller and registers CRDs like BucketClass, BucketClaim, and BucketAccess.\nAlternatively, you can preview the resources before applying them:\nkubectl apply \\ --dry-run=client -o=yaml \\ -k \u0026#39;https://github.com/kubernetes-sigs/container-object-storage-interface//?ref=v0.2.1\u0026#39; COSI Driver for Linode # Providers implement COSI through drivers. Here, weâ€™ll use the Linode COSI Driver to manage Linode Object Storage buckets:\nAdd the Helm repository:\nhelm repo add linode-cosi-driver \\ https://linode.github.io/linode-cosi-driver Install the driver, substituting your Linode API token. The token must be configured with the following permissions Object Storage - Read/Write. Make sure to replace \u0026lt;your-linode-api-token\u0026gt; with your actual token:\nhelm install linode-cosi-driver \\ linode-cosi-driver/linode-cosi-driver \\ --set=apiToken=\u0026#34;\u0026lt;your-linode-api-token\u0026gt;\u0026#34; \\ --namespace=linode-cosi-driver \\ --create-namespace Classes # Define a BucketClass # A BucketClass specifies storage policies. Below, we create two classes - one that deletes buckets automatically and another that retains them:\n# delete-policy.yaml apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketClass metadata: name: linode-objectstorage driverName: objectstorage.cosi.linode.com deletionPolicy: Delete parameters: cosi.linode.com/v1/region: us-east # retain-policy.yaml apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketClass metadata: name: linode-objectstorage-retain driverName: objectstorage.cosi.linode.com deletionPolicy: Retain parameters: cosi.linode.com/v1/region: us-east Define a BucketAccessClass # A BucketAccessClass controls how applications authenticate to buckets. Here, we use API keys:\n# bucket-access-class.yaml apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketAccessClass metadata: name: linode-objectstorage driverName: objectstorage.cosi.linode.com authenticationType: Key parameters: {} Apply these manifests with kubectl apply -f \u0026lt;file\u0026gt;.yaml.\nSample Application # Letâ€™s deploy an app that writes logs to a COSI-managed bucket. The deployment includes:\nA logger sidecar container that generates logs. An uploader container that syncs logs to object storage. A BucketClaim to request a bucket. A BucketAccess to manage credentials. # cosi-resources.yaml apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketAccess metadata: name: cosi-sample-app namespace: cosi-sample spec: bucketAccessClassName: linode-objectstorage bucketClaimName: cosi-sample-app credentialsSecretName: s3-credentials protocol: S3 --- apiVersion: objectstorage.k8s.io/v1alpha1 kind: BucketClaim metadata: name: cosi-sample-app namespace: cosi-sample spec: bucketClassName: linode-objectstorage protocols: - S3 # cosi-sample-app.yaml apiVersion: v1 kind: Namespace metadata: name: cosi-sample --- apiVersion: apps/v1 kind: Deployment metadata: name: cosi-sample-app namespace: cosi-sample spec: selector: matchLabels: app: uploader template: metadata: labels: app: uploader spec: containers: - args: - --upload-interval=240 - --file=/mnt/logs/log.txt image: ghcr.io/anza-labs/cosi-sample-app:latest imagePullPolicy: IfNotPresent name: uploader resources: requests: cpu: 100m memory: 256Mi securityContext: readOnlyRootFilesystem: true runAsNonRoot: true volumeMounts: - mountPath: /mnt/logs name: logs - mountPath: /cosi name: cosi-secret initContainers: - args: - -c - | #!/bin/ash while true; do echo \u0026#34;$(date +\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) - Log entry\u0026#34; | tee -a \u0026#34;$LOG_FILE\u0026#34; # Check file size and trim if needed if [ -f \u0026#34;$LOG_FILE\u0026#34; ] \u0026amp;\u0026amp; [ $(stat -c %s \u0026#34;$LOG_FILE\u0026#34;) -gt $MAX_SIZE ]; then echo \u0026#34;$(date +\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;) - Rotating\u0026#34; | tee -a \u0026#34;$LOG_FILE.tmp\u0026#34; mv \u0026#34;$LOG_FILE.tmp\u0026#34; \u0026#34;$LOG_FILE\u0026#34; fi sleep 10 done command: - sh env: - name: LOG_FILE value: /mnt/logs/log.txt - name: MAX_SIZE value: \u0026#34;4194304\u0026#34; image: alpine:3.21 name: logger resources: requests: cpu: 50m memory: 64Mi restartPolicy: Always securityContext: readOnlyRootFilesystem: true runAsGroup: 1000 runAsNonRoot: true runAsUser: 1000 volumeMounts: - mountPath: /mnt/logs name: logs volumes: - name: cosi-secret secret: secretName: s3-credentials - emptyDir: {} name: logs Key Components Explained: # BucketClaim: Requests a bucket using the linode-objectstorage class. BucketAccess: References the BucketAccessClass to generate credentials stored in a s3-credentials Secret. Volumes: The cosi-secret volume mounts the credentials, while the logs volume is a temporary emptyDir for log storage. Benefits # Without COSI # Manual Steps: Create buckets via provider UIs/CLIs, manage credentials, and hardcode them in manifests. Risk: Credentials exposed in code; no lifecycle management. With COSI # Dynamic Provisioning: Buckets and credentials created on-demand via Kubernetes API. Automated Cleanup: Set deletionPolicy: Delete to remove unused buckets. Security: Credentials injected via Secrets, never stored in plaintext. Conclusion # COSI brings the flexibility of Kubernetes-native resource management to object storage. By defining policies through BucketClass and BucketAccessClass, teams can streamline storage operations while enforcing security and lifecycle rules. The Linode driver example demonstrates how easily COSI integrates with cloud providers, but the same principles apply to AWS S3, Google Cloud Storage, and more.\nReady to try it? Deploy the sample app and watch COSI automate the heavy lifting! ðŸš€\n","date":"6 July 2025","externalUrl":null,"permalink":"/posts/2025/0706-cosi-getting-started/","section":"Posts","summary":"Learn how to integrate the Container Object Storage Interface (COSI) with Kubernetes to automate object storage provisioning, access management, and application integration.","title":"Getting Started with COSI: Simplifying Object Storage in Kubernetes","type":"posts"},{"content":" Name Description Link kubespec.dev Web-based Kubernetes API specification tool Click talos.dev Talos Linux - A modern, secure, and minimal OS for Kubernetes Click omni.siderolabs.com Omni - A tool for managing Kubernetes clusters Click ","externalUrl":null,"permalink":"/library/","section":"Stateless by design","summary":"","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" RPA developer and automation specialist optimizing complex workflows with innovative process automation and data-driven insights.\n","externalUrl":null,"permalink":"/authors/niesmaczne/","section":"Authors","summary":"","title":"Nikola Borska","type":"authors"}]